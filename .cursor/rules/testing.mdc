---
description: 
globs: test/*
alwaysApply: false
---
Defines testing principles and conventions for the app.

# UPDATING OR ADDING TESTS
  1. Update the feature's `test_plan.md` with new test groups and cases.
  2. Import and execute the new test file in the corresponding `test/runners` files.
  3. If it's a widget test, add it to `test/runners/all_widget_tests.dart`.
  4. Ensure `@Tags(['feature_name'])` is present in the new test file.

# TEST STRUCTURE
Follow feature-based test structure mirroring `lib/features/`.

# TEST TYPES
- **Unit tests** → Pure logic, use cases, repositories (mock dependencies)
- **Widget tests** → UI components (Golden tests optional)
- **Integration tests** → End-to-end feature flows

# NAMING CONVENTIONS
- File names: `<class>_test.dart`
- Test group: `'[Feature] <Behavior>'`
- Test name: `'should <expected behavior> when <condition>'`
- **Tags**: When adding new `@Tags([...])` to test files, always add them to `dart_test.yaml` under the `tags:` section.

# MOCKING
- Use `mocktail` for mocks.
- Use fake data builders for entities (e.g. `FakeBiomarker`).
- Avoid hitting live Supabase or Drift DB in tests — use in-memory DB.

# COVERAGE
- Maintain >85% coverage on domain & data layers.
- Exclude generated code and UI constants from coverage.

# CI/CD
- All tests run on GitHub Actions.
- Lint and tests must pass before merge.

# ASSERTIONS
- Prefer `expectLater()` for async checks.
- Use `verify()` for mock verification.
- Avoid brittle widget tree matchers — use keys and finders.

# DOCUMENTATION & MAINTENANCE
- **Test Plans**: Every feature MUST have a corresponding `test/plans/<feature>_test_plan.md`.
- **Test Runners**: Every feature MUST have runners in `test/runners/<feature>/` (quick, unit, all).
- **Global Runners**: Maintain `test/runners/all_widget_tests.dart` for all widget tests.
- Reference:
- **docs/architecture/system_design.md** for architecture coverage expectations.
- **docs/architecture/data_flow.md** for correct repository and entity boundaries.
