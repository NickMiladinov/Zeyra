---
description: 
globs: *.dart
alwaysApply: false
---
Applies Flutter best practices and coding guidelines, focusing on constants, themes, utilities, and widgets.

# NAMING CONVENTIONS
- **Classes**: PascalCase → `UserProfile`, `BiomarkerRepository`
- **Methods**: lowerCamelCase → `fetchBiomarkers()`, `saveUserProfile()`
- **Variables**: lowerCamelCase → `userProfile`, `selectedPregnancy`
- **Constants**: UPPER_SNAKE_CASE → `DEFAULT_LANGUAGE = 'en'`
- **Enums**: PascalCase + UpperCamel values → `enum Gender { male, female, other }`
- **Files**: snake_case → `user_profile_repository.dart`, `biomarker_card.dart`
- **Directories**: lowercase_with_underscores → `biomarkers/data/`
- **Providers**: suffix `_provider` → `user_profile_provider`
- **Widgets**: must be stateless unless justified otherwise

# FLUTTER ARCHITECTURE RULES
- Use **Riverpod** for dependency injection and state.
- Avoid direct DB/API calls in UI.
- Logic goes into `logic/` and use cases in `domain/usecases/`.
- Repository interfaces defined in `domain/repositories/`.
- Repository implementations live in `data/repositories/`.
- UI widgets consume providers only; never directly access repositories.
- **State Management (Notifiers/Blocs)** must rely on **UseCases** as the Single Source of Truth.
- **UseCases** should return the updated entity after modifications so UI state can be updated authoritatively.
- UI Logic should NEVER calculate/predict state changes manually (avoid guessing new state).
- UI Logic must NEVER directly access Repositories.

# CODE STYLE
- Adapt to existing project architecture while maintaining clean code principles.
- Always use `const` constructors when possible.
- Use `final` for immutable local variables.
- Always provide meaningful widget keys.
- Prefer composition (break large widgets into smaller ones).
- Keep widget build methods short (<100 lines).
- Use `Theme.of(context)` and `AppColors`, `AppEffects`, `AppIcons`, `AppSpacing`, `AppTypography` from `app/theme/`.
- Use extension methods (in `shared/extensions/`) for repeated logic.
- Ensure `lint` passes (`flutter analyze` clean).
- Implement proper null safety practices.

# THEME CONSTANTS (CRITICAL)
- **ALWAYS use theme constants** from `app/theme/` instead of hardcoded values if possible:
  - **Colors**: Use `AppColors.*` (primary, secondary, white, textPrimary, etc.) - NEVER use `Color(0xFF...)` or `Colors.*` directly
  - **Spacing**: Use `AppSpacing.*` (xs, sm, md, lg, xl, padding*, margin*, gap*, screen*, icon*, button*, etc.)
  - **Typography**: Use `AppTypography.*` (displayLarge, headlineMedium, bodyLarge, labelSmall, etc.)
  - **Effects**: Use `AppEffects.*` (rounded*, shadow*, border*, opacity*, duration*, curve*)
  - **Icons**: Use `AppIcons.*` methods (icon(), active(), baby(), etc.) with Material Symbols
- **Examples of FORBIDDEN hardcoded values**:
  - ❌ `height: 24` → ✅ `height: AppSpacing.iconSM`
  - ❌ `fontSize: 16` → ✅ `style: AppTypography.bodyLarge`
  - ❌ `Color(0xFF4DB6AC)` → ✅ `AppColors.primary`
  - ❌ `BorderRadius.circular(12)` → ✅ `AppEffects.roundedMD`
  - ❌ `EdgeInsets.all(16)` → ✅ `EdgeInsets.all(AppSpacing.paddingLG)`
  - ❌ `Duration(milliseconds: 200)` → ✅ `AppEffects.durationFast`
- If a needed constant doesn't exist, **add it to the appropriate theme file** rather than hardcoding
- Exception: Design-specific values unique to a component (document why with a comment)

# CUSTOM WIDGETS (DESIGN SYSTEM)
- **NEVER use Material widgets directly** when custom app widgets exist
- When in doubt, check `shared/widgets/` for existing custom components first

# FIGMA DESIGN INTERPRETATION
- **IGNORE OS-level elements** in Figma screenshots/designs:
  - ❌ Home indicator bars (bottom gesture bar on iOS/Android)
  - ❌ Status bars (time, battery, signal at top)
  - ❌ System navigation (back button, home button on Android)
  - ❌ Notches, camera cutouts, rounded screen corners
- **Only implement app-level UI** - the OS handles its own elements
- If unsure whether an element is OS-level or app-level, ask for clarification
- Figma dimensions that include OS elements should be adjusted to exclude them

# ERROR HANDLING
- Define custom exceptions in `core/errors/`.
- Catch at the repository level, map to domain-friendly failures.
- Avoid silent catches.
- Log handled errors via `core/monitoring/`.

# DEPENDENCY INJECTION
- Register all global providers in `core/di/main_providers.dart`.
- **All async service initialization must happen in `DIGraph.initialize()`** in `core/di/di_graph.dart`.
- Service initialization order is critical - documented in `di_graph.dart` (do not change).
- Access initialized services via providers or `DIGraph.*` getters.
- Never use singletons outside DI.
- Avoid runtime service locators; prefer compile-time DI.

# DOCUMENTATION
- All public classes and methods must include DartDoc comments.
- Reference **docs/data/data_flow.md** when implementing repositories or entities.

# CODE CONSISTENCY
- Ensure domain entities never depend on Flutter or Drift imports.
- Data models (DTOs) mirror DB/API schema and map to/from domain entities.
- Follow reactive update rules only for timeline, AI chat, and live trackers.

# NAVIGATION
- **ALWAYS use `CupertinoPageRoute`** for all screen transitions
- **Button Debouncing**: For critical action buttons (timers, trackers, form submissions), implement a debounce flag

# UI
- Accessible text sizes and color contrast.
- Follow design tokens from `app/theme/`.
- Use `SizedBox` and `Padding` over hardcoded spacers.
- Reuse `shared/widgets/` components whenever possible.

# Optimisation
- Implement proper list view optimization.
- Use proper build methods optimization.
- Follow proper compilation optimization techniques.

# CODE REVIEW CHECKLIST (ALWAYS CHECK BEFORE FINISHING)
- **Scan for hardcoded numbers** in your code:
  - Search for patterns like: `height: \d+`, `width: \d+`, `EdgeInsets.all(\d+)`, `padding: \d+`, `fontSize: \d+`, etc.
  - Replace with theme constants from `AppSpacing`, `AppTypography`, etc.
- **Scan for hardcoded colors**:
  - Search for: `Color(0x`, `Colors.`, hex color values
  - Replace with `AppColors.*` constants
- **Scan for magic strings**:
  - Hard-coded text that should be localized or constants
- **Check imports**:
  - Remove unused imports
  - Use theme imports when using theme constants
- **Run before completing**: `flutter analyze` to catch any compilation errors
