import 'dart:io' hide Platform;
import 'dart:typed_data';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:file_picker/file_picker.dart';
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';
import 'package:plugin_platform_interface/plugin_platform_interface.dart';
import 'package:uuid/uuid.dart';
import 'package:logger/logger.dart';
import 'package:pointycastle/export.dart' as pc;

import 'package:zeyra/core/services/secure_file_storage_service.dart';
import 'package:zeyra/core/services/database_helper.dart';
import 'package:zeyra/core/helpers/crypto_utils.dart';
import 'package:zeyra/core/services/file_system_operations.dart';

// IMPORTANT: Ensure this file is generated by running `flutter pub run build_runner build --delete-conflicting-outputs`
// The @GenerateMocks annotation will ensure mockito can generate mocks for classes.
// For typedefs, we create manual mock classes.
import 'secure_file_storage_service_test.mocks.dart';

// Test-specific subclass for SecureFileStorageService
class TestableSecureFileStorageService extends SecureFileStorageService {
  PlatformFile? mockPickFileResult;
  int pickFileForTestCallCount = 0;
  int encryptAndStoreFileForTestCallCount = 0;
  // PlatformFile? lastArgToEncryptAndStoreFile; // Uncomment if needed for other tests

  final Logger serviceLogger;
  final Uuid serviceUuid;

  TestableSecureFileStorageService({
    required FlutterSecureStorage secureStorage,
    required DatabaseHelper dbHelper,
    required Uuid uuid,
    required Logger logger,
    required FileSystemOperations fileSystemOps,
  })  : serviceLogger = logger, // Store for local use in overridden methods
        serviceUuid = uuid,   // Store for local use in overridden methods
        super(
          secureStorage: secureStorage,
          dbHelper: dbHelper,
          uuid: uuid, // Pass to superclass
          logger: logger, // Pass to superclass
          fileSystemOps: fileSystemOps,
        );

  @override
  Future<PlatformFile?> pickFileForTest() async {
    pickFileForTestCallCount++;
    return mockPickFileResult;
  }

  @override
  Future<Map<String, String>?> encryptAndStoreFileForTest(PlatformFile platformFile) async {
    encryptAndStoreFileForTestCallCount++;
    // lastArgToEncryptAndStoreFile = platformFile; // Uncomment if needed
    // For this test, we expect this NOT to be called.
    // If it were called in other tests using this subclass,
    // super call would execute original logic.
    // return super.encryptAndStoreFileForTest(platformFile);

    // If pickFileForTest was supposed to succeed and return a file,
    // we might simulate a successful encryption response here for other tests.
    // For this specific test where picking fails, this part is not crucial
    // as encryptAndStoreFileForTestCallCount should remain 0.
    if (mockPickFileResult != null) {
        // Simulate a successful encryption result.
        // This is a placeholder; adapt if actual structure is needed for other tests.
        return {'fileId': 'simulated-file-id', 'path': 'simulated/path.enc'};
    }
    return null; // Should not be reached if pickFileForTest returns null and this method is called.
  }

  // Override pickAndSecureFile to use the testable methods from this class
  @override
  Future<Map<String, String>?> pickAndSecureFile() async {
    // Calls the overridden pickFileForTest from *this* class
    final PlatformFile? platformFile = await pickFileForTest();

    if (platformFile == null) {
      serviceLogger.i('File picking cancelled or failed.'); // Use the stored mock logger
      return null;
    }
    // Calls the overridden encryptAndStoreFileForTest from *this* class
    return await encryptAndStoreFileForTest(platformFile);
  }
}

// Mock for PathProviderPlatform
class MockPathProvider extends Mock with MockPlatformInterfaceMixin implements PathProviderPlatform {
  // Add explicit overrides for methods that are stubbed
  @override
  Future<String?> getApplicationDocumentsPath() =>
      super.noSuchMethod(
        Invocation.method(#getApplicationDocumentsPath, []),
        returnValue: Future.value(null), // Default valid Future<String?>
        returnValueForMissingStub: Future.value(null) // Ensure Future for missing stub
      ) as Future<String?>;

  @override
  Future<String?> getTemporaryPath() =>
      super.noSuchMethod(
        Invocation.method(#getTemporaryPath, []),
        returnValue: Future.value(null),
        returnValueForMissingStub: Future.value(null)
      ) as Future<String?>;
  
  // Other methods from PathProviderPlatform are not overridden here as they are not directly stubbed in these tests.
  // If other methods were needed, they would be added similarly.
}

@GenerateNiceMocks([
  MockSpec<FlutterSecureStorage>(),
  MockSpec<PlatformFile>(),
  MockSpec<DatabaseHelper>(),
  MockSpec<Uuid>(),
  MockSpec<Logger>(),
  MockSpec<Directory>(), 
  MockSpec<SecureFileStorageService>(), 
  MockSpec<FileSystemOperations>(),
])
void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  late SecureFileStorageService secureFileStorageService;
  late MockFlutterSecureStorage mockSecureStorage;
  late MockDatabaseHelper mockDbHelper;
  late MockUuid mockUuid;
  late MockPathProvider mockPathProviderPlatform;
  late MockLogger mockLogger;
  late MockFileSystemOperations mockFileSystemOps;
  late MockDirectory mockDirectoryInstance;

  const String mockAppDocumentsPath = '/mock/documents/path';
  const String encryptedFilesDirName = 'encrypted_medical_files';
  final String expectedSecureDirPath = '$mockAppDocumentsPath/$encryptedFilesDirName';

  final testFileId = 'test-file-id-123';
  final testEncryptedFileNameUuid = 'test-encrypted-uuid';
  final testEncryptedFileName = '$testEncryptedFileNameUuid.enc';
  final testEncryptionKey = Uint8List.fromList(List.generate(32, (idx) => idx + 1));
  final testIv = Uint8List.fromList(List.generate(12, (idx) => idx + 100));
  final testPlaintextData = Uint8List.fromList('Hello, secure world!'.codeUnits);
  late Uint8List testEncryptedData;
  final String mockEncryptedFilePath = '$expectedSecureDirPath/$testEncryptedFileName';

  // Helper to perform AES GCM encryption for test setup (remains the same)
  Uint8List aesGcmEncrypt(Uint8List plaintext, Uint8List key, Uint8List iv) {
    final cipher = pc.GCMBlockCipher(pc.AESEngine());
    cipher.init(true, pc.ParametersWithIV<pc.KeyParameter>(pc.KeyParameter(key), iv));
    return cipher.process(plaintext);
  }

  setUpAll(() {
    testEncryptedData = aesGcmEncrypt(testPlaintextData, testEncryptionKey, testIv);
  });

  setUp(() {
    // 1. Instantiate all mocks
    mockSecureStorage = MockFlutterSecureStorage();
    mockDbHelper = MockDatabaseHelper();
    mockUuid = MockUuid();
    mockPathProviderPlatform = MockPathProvider();
    mockLogger = MockLogger();
    mockFileSystemOps = MockFileSystemOperations();
    mockDirectoryInstance = MockDirectory(); 

    // 2. Stub simple properties/methods of mocks that are returned by other mocks FIRST
    // This is CRUCIAL for mockDirectoryInstance.path to avoid "when within a stub response"
    when(mockDirectoryInstance.path).thenReturn(expectedSecureDirPath); 

    // 3. Set up platform instances
    PathProviderPlatform.instance = mockPathProviderPlatform;

    // 4. Stub methods of mocks that might be called by the SUT constructor or initial setup
    when(mockPathProviderPlatform.getApplicationDocumentsPath()).thenAnswer((_) async => mockAppDocumentsPath);
    when(mockPathProviderPlatform.getTemporaryPath()).thenAnswer((_) async => '/mock/temporary/path');
    
    // Default stubs for FileSystemOperations
    when(mockFileSystemOps.fileExists(argThat(isA<String>()))).thenAnswer((_) async => true);
    when(mockFileSystemOps.readFileAsBytes(argThat(isA<String>()))).thenAnswer((_) async => Uint8List(0)); // Default to empty bytes
    when(mockFileSystemOps.writeFileAsBytes(argThat(isA<String>()), argThat(isA<Uint8List>()), flush: argThat(isA<bool>(), named: 'flush')))
        .thenAnswer((_) async { /* Explicitly complete for Future<void> */ });
    when(mockFileSystemOps.directoryExists(argThat(isA<String>()))).thenAnswer((_) async => true);
    when(mockFileSystemOps.createDirectory(argThat(isA<String>()), recursive: argThat(isA<bool>(), named: 'recursive')))
        .thenAnswer((_) async => mockDirectoryInstance); // Returns an already-stubbed mockDirectoryInstance
    when(mockFileSystemOps.deleteFile('dummy_path_for_default_stub')) // General stub for deleteFile using dummy string
        .thenAnswer((_) async { /* Explicitly complete for Future<void> */ });

    // 5. Stub common SUT dependencies (order can matter if they interact)
    // Ensure enough UUIDs are vended if SUT constructor or early methods use them.
    // If more than 2 are needed by the service during its instantiation or early implicit calls in setUp,
    // this list might need to be longer or have a default thenReturn at the end.
    when(mockUuid.v4()).thenReturnInOrder([testFileId, testEncryptedFileNameUuid, 'uuid-3', 'uuid-4', 'uuid-5']); // Provide a few more for safety

    // Default stubs for logger methods (using specific matchers for e and w)
    when(mockLogger.i(any)).thenReturn(null);
    when(mockLogger.d(any)).thenReturn(null);
    when(mockLogger.w(any, error: anyNamed('error'), stackTrace: anyNamed('stackTrace'))).thenReturn(null);
    when(mockLogger.e(any, error: anyNamed('error'), stackTrace: anyNamed('stackTrace'), time: anyNamed('time'))).thenReturn(null);
    
    // Default stubs for DatabaseHelper
    when(mockDbHelper.saveMedicalFileMetadata(any)).thenAnswer((_) async {});
    when(mockDbHelper.getMedicalFileMetadataById(any)).thenAnswer((_) async => null); // Default to not found
    
    // Default stubs for FlutterSecureStorage
    when(mockSecureStorage.write(key: anyNamed('key'), value: anyNamed('value'))).thenAnswer((_) async {});
    when(mockSecureStorage.read(key: anyNamed('key'))).thenAnswer((_) async => null); // Default to not found
    when(mockSecureStorage.delete(key: anyNamed('key'))).thenAnswer((_) async {});

    // 6. Finally, instantiate the service under test
    secureFileStorageService = SecureFileStorageService(
      secureStorage: mockSecureStorage,
      dbHelper: mockDbHelper,
      uuid: mockUuid,
      logger: mockLogger,
      fileSystemOps: mockFileSystemOps,
    );
  });

  tearDown(() {
    PathProviderPlatform.instance = MockPathProvider();
  });

  group('SecureFileStorageService (FileSystemOperations Mocked) - getSecureStorageDirectoryForTest', () {
    test('should return correct path and create directory if it does not exist', () async {
      when(mockFileSystemOps.directoryExists(expectedSecureDirPath)).thenAnswer((_) async => false);
      
      final path = await secureFileStorageService.getSecureStorageDirectoryForTest();
      
      expect(path, expectedSecureDirPath);
      verify(mockFileSystemOps.directoryExists(expectedSecureDirPath)).called(1);
      verify(mockFileSystemOps.createDirectory(expectedSecureDirPath, recursive: true)).called(1);
    });

    test('should return correct path and NOT create directory if it exists', () async {
      when(mockFileSystemOps.directoryExists(expectedSecureDirPath)).thenAnswer((_) async => true);

      final path = await secureFileStorageService.getSecureStorageDirectoryForTest();

      expect(path, expectedSecureDirPath);
      verify(mockFileSystemOps.directoryExists(expectedSecureDirPath)).called(1);
      verifyNever(mockFileSystemOps.createDirectory(argThat(isA<String>()), recursive: argThat(isA<bool>(), named: 'recursive')));
    });
  });

  group('SecureFileStorageService (FileSystemOperations Mocked) - encryptAndStoreFileForTest', () {
    late MockPlatformFile mockPlatformFile;
    const String pickedFileName = 'source_file.pdf';
    const String pickedFileExtension = 'pdf';
    final String pickedFilePath = '/mock/source/$pickedFileName';

    setUp(() {
      mockPlatformFile = MockPlatformFile();
      when(mockPlatformFile.path).thenReturn(pickedFilePath);
      when(mockPlatformFile.name).thenReturn(pickedFileName);
      when(mockPlatformFile.size).thenReturn(testPlaintextData.length);
      when(mockPlatformFile.extension).thenReturn(pickedFileExtension);

      // Reset UUIDs for this group as it has specific expectations if not overridden
      when(mockUuid.v4()).thenReturnInOrder([testFileId, testEncryptedFileNameUuid]);

      when(mockFileSystemOps.readFileAsBytes(pickedFilePath)).thenAnswer((_) async => testPlaintextData);
      when(mockFileSystemOps.directoryExists(expectedSecureDirPath)).thenAnswer((_) async => true);
    });

    test('successfully encrypts, stores key, writes file, and saves metadata', () async {
      final result = await secureFileStorageService.encryptAndStoreFileForTest(mockPlatformFile);

      expect(result, isNotNull);
      expect(result!['fileId'], testFileId);
      expect(result['path'], mockEncryptedFilePath);

      verify(mockFileSystemOps.readFileAsBytes(pickedFilePath)).called(1);
      verify(mockSecureStorage.write(key: testFileId, value: argThat(isA<String>(), named: 'value'))).called(1);
      verify(mockFileSystemOps.writeFileAsBytes(
        mockEncryptedFilePath, 
        argThat(isA<Uint8List>()), 
        flush: true
      )).called(1);
      
      final capturedMetadataList = verify(mockDbHelper.saveMedicalFileMetadata(captureAny)).captured;
      expect(capturedMetadataList.length, 1);
      final Map<String, dynamic> savedMetadata = capturedMetadataList.single as Map<String, dynamic>;
      expect(savedMetadata[DatabaseHelper.colId], testFileId);
      expect(savedMetadata[DatabaseHelper.colEncryptedPath], mockEncryptedFilePath);
      expect(savedMetadata[DatabaseHelper.colOriginalFilename], pickedFileName);
      expect(savedMetadata[DatabaseHelper.colFileType], pickedFileExtension);
      expect(savedMetadata[DatabaseHelper.colFileSize], testPlaintextData.length);
      expect(savedMetadata[DatabaseHelper.colDateAdded], isA<int>());
    });

    test('returns null if platformFile.path is null', () async {
      when(mockPlatformFile.path).thenReturn(null);
      final result = await secureFileStorageService.encryptAndStoreFileForTest(mockPlatformFile);
      expect(result, isNull);
      verify(mockLogger.e(argThat(contains('Picked file path is null')))).called(1);
      verifyNever(mockFileSystemOps.readFileAsBytes(argThat(isA<String>())));
    });

    test('returns null and logs error if readFileAsBytes throws', () async {
      when(mockFileSystemOps.readFileAsBytes(pickedFilePath)).thenThrow(Exception('Failed to read file'));
      final result = await secureFileStorageService.encryptAndStoreFileForTest(mockPlatformFile);
      expect(result, isNull);

      final captured = verify(mockLogger.e(
        captureAny, // message
        error: captureAnyNamed('error'), 
        stackTrace: captureAnyNamed('stackTrace'),
        time: captureAnyNamed('time') // Capture time
      )).captured;
      expect(captured[0] as String, contains('Error encrypting and storing file ${mockPlatformFile.name}: Exception: Failed to read file'));
      expect(captured[1], isA<Exception>());
      // captured[2] is stackTrace, captured[3] is time (can assert if needed, e.g., expect(captured[3], isNull);)
    });

    test('returns null and logs error if writeFileAsBytes throws', () async {
      when(mockFileSystemOps.writeFileAsBytes(
        mockEncryptedFilePath, 
        argThat(isA<Uint8List>()), 
        flush: argThat(isA<bool>(), named: 'flush')
      )).thenThrow(Exception('Disk full'));

      // Setup for cleanup attempt
      when(mockSecureStorage.delete(key: testFileId)).thenAnswer((_) async {}); 
      when(mockFileSystemOps.fileExists(mockEncryptedFilePath)).thenAnswer((_) async => true); 
      // Use the most direct path construction for this critical stub
      when(mockFileSystemOps.deleteFile('$expectedSecureDirPath/$testEncryptedFileNameUuid.enc')).thenAnswer((_) async {});

      final result = await secureFileStorageService.encryptAndStoreFileForTest(mockPlatformFile);
      expect(result, isNull);

      // Verify the primary error log for "Disk full"
      final capturedErrorLog = verify(mockLogger.e(
        captureAny, // message
        error: captureAnyNamed('error'), 
        stackTrace: captureAnyNamed('stackTrace'),
        time: captureAnyNamed('time') // Capture time
      )).captured;
      expect(capturedErrorLog[0] as String, contains('Error encrypting and storing file ${mockPlatformFile.name}: Exception: Disk full'));
      expect(capturedErrorLog[1], isA<Exception>());
      
      // Verify cleanup attempts (warning and actual operations)
      // Logger.w has a different signature (message, error, stackTrace), no time by default in our wrapper if not specified.
      verify(mockLogger.w(argThat(contains('Attempting to clean up due to failure during encryption/storage for fileId: $testFileId')))).called(1);
      verify(mockSecureStorage.delete(key: testFileId)).called(1);
      verify(mockFileSystemOps.deleteFile('$expectedSecureDirPath/$testEncryptedFileNameUuid.enc')).called(1); 
      // No MissingStubError should be logged for deleteFile now.
    });

    test('returns null and logs error if _secureStorage.write throws', () async {
      when(mockSecureStorage.write(key: testFileId, value: anyNamed('value')))
          .thenThrow(Exception('Failed to write to secure storage'));
      
      when(mockSecureStorage.delete(key: testFileId)).thenAnswer((_) async {});

      final result = await secureFileStorageService.encryptAndStoreFileForTest(mockPlatformFile);
      expect(result, isNull);

      final captured = verify(mockLogger.e(
        captureAny, // message
        error: captureAnyNamed('error'), 
        stackTrace: captureAnyNamed('stackTrace'),
        time: captureAnyNamed('time') // Capture time
      )).captured;
      expect(captured[0] as String, contains('Error encrypting and storing file ${mockPlatformFile.name}: Exception: Failed to write to secure storage'));
      expect(captured[1], isA<Exception>());

      verify(mockLogger.w(argThat(contains('Attempting to clean up due to failure during encryption/storage for fileId: $testFileId')))).called(1);
      verify(mockSecureStorage.delete(key: testFileId)).called(1);
      verifyNever(mockFileSystemOps.deleteFile('dummy_path_for_type_check'));
    });

    test('returns null, logs error, and attempts cleanup if _dbHelper.saveMedicalFileMetadata throws', () async {
      when(mockDbHelper.saveMedicalFileMetadata(any))
          .thenThrow(Exception('Failed to save metadata to DB'));
      
      // Ensure file system ops are set up for potential cleanup
      when(mockFileSystemOps.fileExists(mockEncryptedFilePath)).thenAnswer((_) async => true);
      when(mockFileSystemOps.deleteFile(mockEncryptedFilePath)).thenAnswer((_) async {});
      when(mockSecureStorage.delete(key: testFileId)).thenAnswer((_) async {}); // testFileId is the first UUID mock

      final result = await secureFileStorageService.encryptAndStoreFileForTest(mockPlatformFile);
      
      expect(result, isNull);
      
      // Verify the primary error log using argument capture
      final capturedErrorLog = verify(mockLogger.e(
        captureAny, // message
        error: captureAnyNamed('error'), 
        stackTrace: captureAnyNamed('stackTrace'),
        time: captureAnyNamed('time') // Capture time
      )).captured;
      expect(capturedErrorLog[0] as String, contains('Error encrypting and storing file ${mockPlatformFile.name}: Exception: Failed to save metadata to DB'));
      expect(capturedErrorLog[1], isA<Exception>()); // Check the error type

      verify(mockLogger.w(argThat(contains('Attempting to clean up due to failure during encryption/storage for fileId: $testFileId')))).called(1);
      verify(mockSecureStorage.delete(key: testFileId)).called(1);
      verify(mockFileSystemOps.deleteFile(mockEncryptedFilePath)).called(1);
    });

    test('successfully encrypts and stores a zero-byte file', () async {
      final mockEmptyPlatformFile = MockPlatformFile();
      when(mockEmptyPlatformFile.path).thenReturn('/mock/source/empty_file.txt');
      when(mockEmptyPlatformFile.name).thenReturn('empty_file.txt');
      when(mockEmptyPlatformFile.size).thenReturn(0);
      when(mockEmptyPlatformFile.extension).thenReturn('txt');

      when(mockFileSystemOps.readFileAsBytes('/mock/source/empty_file.txt')).thenAnswer((_) async => Uint8List(0));
      // Use different UUIDs for this specific test run to avoid collision with other tests using fixed UUIDs.
      final uniqueFileId = 'zero-byte-file-id';
      final uniqueEncryptedUuid = 'zero-byte-encrypted-uuid';
      final uniqueEncryptedPath = '$expectedSecureDirPath/$uniqueEncryptedUuid.enc';

      when(mockUuid.v4()).thenReturnInOrder([uniqueFileId, uniqueEncryptedUuid]);

      final result = await secureFileStorageService.encryptAndStoreFileForTest(mockEmptyPlatformFile);

      expect(result, isNotNull);
      expect(result!['fileId'], uniqueFileId);
      expect(result['path'], uniqueEncryptedPath);

      verify(mockFileSystemOps.readFileAsBytes('/mock/source/empty_file.txt')).called(1);
      verify(mockSecureStorage.write(key: uniqueFileId, value: anyNamed('value'))).called(1);
      final capturedEncryptedBytes = verify(mockFileSystemOps.writeFileAsBytes(
        uniqueEncryptedPath, 
        captureAny, // Capture the encrypted bytes
        flush: true
      )).captured.single as Uint8List;
      // GCM on empty data results in just the auth tag (16 bytes for AES-256 GCM)
      expect(capturedEncryptedBytes.length, 16);
      
      final capturedMetadataList = verify(mockDbHelper.saveMedicalFileMetadata(captureAny)).captured;
      expect(capturedMetadataList.length, 1);
      final Map<String, dynamic> savedMetadata = capturedMetadataList.single as Map<String, dynamic>;
      expect(savedMetadata[DatabaseHelper.colId], uniqueFileId);
      expect(savedMetadata[DatabaseHelper.colOriginalFilename], 'empty_file.txt');
      expect(savedMetadata[DatabaseHelper.colFileSize], 0);
    });
  });

  group('SecureFileStorageService (FileSystemOperations Mocked) - decryptFile', () {
    setUp((){
      when(mockDbHelper.getMedicalFileMetadataById(testFileId)).thenAnswer((_) async => {
        DatabaseHelper.colId: testFileId,
        DatabaseHelper.colEncryptedPath: mockEncryptedFilePath,
      });
      final String knownGoodKeyIv = '${bytesToHex(testEncryptionKey)}:${bytesToHex(testIv)}';
      when(mockSecureStorage.read(key: testFileId)).thenAnswer((_) async => knownGoodKeyIv);
      when(mockFileSystemOps.fileExists(mockEncryptedFilePath)).thenAnswer((_) async => true);
      when(mockFileSystemOps.readFileAsBytes(mockEncryptedFilePath)).thenAnswer((_) async => testEncryptedData);
    });

    test('successfully decrypts file if key, data are valid and file exists', () async {
      final decryptedData = await secureFileStorageService.decryptFile(testFileId);

      expect(decryptedData, equals(testPlaintextData));
      verify(mockDbHelper.getMedicalFileMetadataById(testFileId)).called(1);
      verify(mockSecureStorage.read(key: testFileId)).called(1);
      verify(mockFileSystemOps.fileExists(mockEncryptedFilePath)).called(1);
      verify(mockFileSystemOps.readFileAsBytes(mockEncryptedFilePath)).called(1);
    });

    test('returns null if metadata is not found', () async {
      when(mockDbHelper.getMedicalFileMetadataById(testFileId)).thenAnswer((_) async => null);
      final decryptedData = await secureFileStorageService.decryptFile(testFileId);
      expect(decryptedData, isNull);
      verify(mockLogger.e(argThat(contains('No metadata, or encrypted path is null/empty in DB for fileId: $testFileId')))).called(1);
    });

    test('returns null if key/IV not found in secure storage', () async {
      when(mockSecureStorage.read(key: testFileId)).thenAnswer((_) async => null);
      final decryptedData = await secureFileStorageService.decryptFile(testFileId);
      expect(decryptedData, isNull);
      verify(mockLogger.e(argThat(contains('No key/IV found for fileId')))).called(1);
    });
    
    test('returns null if encrypted file does not exist (checked by fileExists)', () async {
      when(mockFileSystemOps.fileExists(mockEncryptedFilePath)).thenAnswer((_) async => false);
      final decryptedData = await secureFileStorageService.decryptFile(testFileId);
      expect(decryptedData, isNull);
      verify(mockLogger.e(argThat(contains('Encrypted file not found at path')))).called(1);
      verifyNever(mockFileSystemOps.readFileAsBytes(argThat(isA<String>())));
    });

    test('returns null if readFileAsBytes throws', () async {
      when(mockFileSystemOps.readFileAsBytes(mockEncryptedFilePath)).thenThrow(Exception('Cannot read encrypted file'));
      final decryptedData = await secureFileStorageService.decryptFile(testFileId);
      expect(decryptedData, isNull);
      
      // Capture arguments to mockLogger.e and assert on the message string
      final captured = verify(mockLogger.e(
        captureAny, 
        error: captureAnyNamed('error'), 
        stackTrace: captureAnyNamed('stackTrace')
      )).captured;
      expect(captured[0] as String, contains('Generic error decrypting file with fileId $testFileId: Exception: Cannot read encrypted file'));
      expect(captured[1], isA<Exception>()); // Verify error type
    });

    test('returns null if key/IV string from secure storage is malformed (FormatException)', () async {
      when(mockSecureStorage.read(key: testFileId)).thenAnswer((_) async => 'badly:formed:key:iv:string');
      final decryptedData = await secureFileStorageService.decryptFile(testFileId);
      expect(decryptedData, isNull);
      verify(mockLogger.e(argThat(contains('Invalid key/IV storage format')))).called(1);
    });

    test('returns null if key/IV string from secure storage causes FormatException during hexToBytes', () async {
      when(mockSecureStorage.read(key: testFileId)).thenAnswer((_) async => 'not-hex:not-hex-either');
      final decryptedData = await secureFileStorageService.decryptFile(testFileId);
      expect(decryptedData, isNull);

      // Capture arguments to mockLogger.e and assert on the message string
      final captured = verify(mockLogger.e(
        captureAny, 
        error: captureAnyNamed('error'), 
        stackTrace: captureAnyNamed('stackTrace')
      )).captured;
      expect(captured[0] as String, contains('Malformed hex data for key/IV) for fileId $testFileId'));
      expect(captured[1], isA<FormatException>()); // Verify error type
    });

    test('returns null if decoded encryption key has incorrect length', () async {
      final shortKey = Uint8List.fromList(List.generate(31, (i) => i)); // 31 bytes
      final validIvHex = bytesToHex(testIv);
      when(mockSecureStorage.read(key: testFileId)).thenAnswer((_) async => '${bytesToHex(shortKey)}:$validIvHex');
      final decryptedData = await secureFileStorageService.decryptFile(testFileId);
      expect(decryptedData, isNull);
      verify(mockLogger.e(argThat(contains('Invalid encryption key length (31 bytes, expected 32)')))).called(1);
    });

    test('returns null if decoded IV has incorrect length', () async {
      final validKeyHex = bytesToHex(testEncryptionKey);
      final shortIv = Uint8List.fromList(List.generate(11, (i) => i)); // 11 bytes
      when(mockSecureStorage.read(key: testFileId)).thenAnswer((_) async => '$validKeyHex:${bytesToHex(shortIv)}');
      final decryptedData = await secureFileStorageService.decryptFile(testFileId);
      expect(decryptedData, isNull);
      verify(mockLogger.e(argThat(contains('Invalid IV length (11 bytes, expected 12)')))).called(1);
    });

    test('returns null if decryption fails due to tampered data (GCM tag mismatch)', () async {
      final String knownGoodKeyIv = '${bytesToHex(testEncryptionKey)}:${bytesToHex(testIv)}';
      when(mockSecureStorage.read(key: testFileId)).thenAnswer((_) async => knownGoodKeyIv);
      
      Uint8List tamperedEncryptedData = Uint8List.fromList(testEncryptedData);
      if (tamperedEncryptedData.isNotEmpty) {
        tamperedEncryptedData[0] = tamperedEncryptedData[0] ^ 0xFF; // Flip some bits
      } else {
        // If original encrypted data is empty (shouldn't happen for non-empty plaintext with GCM)
        // create some dummy non-empty data to ensure it can be "tampered"
        tamperedEncryptedData = Uint8List.fromList([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]);
      }

      when(mockFileSystemOps.readFileAsBytes(mockEncryptedFilePath)).thenAnswer((_) async => tamperedEncryptedData);

      final decryptedData = await secureFileStorageService.decryptFile(testFileId);
      expect(decryptedData, isNull);

      // Capture arguments to mockLogger.e and assert on the message string
      final captured = verify(mockLogger.e(
        captureAny, 
        error: captureAnyNamed('error'), 
        stackTrace: captureAnyNamed('stackTrace')
      )).captured;
      expect(captured[0] as String, contains('Data integrity check failed - GCM tag mismatch) for fileId $testFileId'));
      expect(captured[1], isA<pc.InvalidCipherTextException>()); // Verify error type
    });

    test('returns null if encrypted path from DB is null', () async {
      when(mockDbHelper.getMedicalFileMetadataById(testFileId)).thenAnswer((_) async => {
        DatabaseHelper.colId: testFileId,
        DatabaseHelper.colEncryptedPath: null, // Null path
      });
      final decryptedData = await secureFileStorageService.decryptFile(testFileId);
      expect(decryptedData, isNull);
      verify(mockLogger.e(argThat(contains('No metadata, or encrypted path is null/empty in DB')))).called(1);
    });

    test('returns null if encrypted path from DB is empty', () async {
      when(mockDbHelper.getMedicalFileMetadataById(testFileId)).thenAnswer((_) async => {
        DatabaseHelper.colId: testFileId,
        DatabaseHelper.colEncryptedPath: '', // Empty path
      });
      final decryptedData = await secureFileStorageService.decryptFile(testFileId);
      expect(decryptedData, isNull);
      verify(mockLogger.e(argThat(contains('No metadata, or encrypted path is null/empty in DB')))).called(1);
    });
  });

  group('SecureFileStorageService (FileSystemOperations Mocked) - pickAndSecureFile (Integrated Flow)', () {
    late MockPlatformFile mockPlatformFileFromPicker;
    const String pickedFileName = 'picked_integration_file.txt';
    final String pickedFilePath = '/mock/picker/$pickedFileName';
    
    setUp(() {
      mockPlatformFileFromPicker = MockPlatformFile();
      when(mockPlatformFileFromPicker.path).thenReturn(pickedFilePath);
      when(mockPlatformFileFromPicker.name).thenReturn(pickedFileName);
      when(mockPlatformFileFromPicker.size).thenReturn(testPlaintextData.length);
      when(mockPlatformFileFromPicker.extension).thenReturn('txt');
    });

    test('full cycle: pick (mocked), encrypt, store, then decrypt successfully', () async {
      // Re-configure UUIDs for this specific test's sequence to ensure no collision from general setUp
      final uUid = Uuid(); // Use a real Uuid for generating test-specific IDs if needed for predictability outside mocks
      final String currentTestFileId = 'integ-${uUid.v4()}'; 
      final String currentTestEncryptedUuid = 'integ-enc-${uUid.v4()}';
      final String currentTestEncryptedPath = '$expectedSecureDirPath/$currentTestEncryptedUuid.enc';

      // Ensure mockUuid returns these specific values for this test
      when(mockUuid.v4()).thenReturnInOrder([currentTestFileId, currentTestEncryptedUuid]);

      // --- Mocking for Encryption Step ---
      when(mockFileSystemOps.readFileAsBytes(pickedFilePath)).thenAnswer((_) async => testPlaintextData);
      
      String? writtenKeyIvEncryption;
      // Capture the key:IV string that is written to secure storage
      when(mockSecureStorage.write(key: currentTestFileId, value: anyNamed('value'))).thenAnswer((invocation) async {
        writtenKeyIvEncryption = invocation.namedArguments[#value] as String;
      });

      Uint8List? capturedEncryptedBytesForWrite;
      // Capture the encrypted bytes that are written to the file system
      when(mockFileSystemOps.writeFileAsBytes(
        currentTestEncryptedPath, 
        argThat(isA<Uint8List>()), 
        flush: argThat(isA<bool>(), named: 'flush')
      )).thenAnswer((invocation) async {
        capturedEncryptedBytesForWrite = invocation.positionalArguments[1] as Uint8List;
      });
      when(mockFileSystemOps.directoryExists(argThat(isA<String>()))).thenAnswer((_) async => true); // Ensure directory exists for write

      // --- Execute Encryption (using test wrapper for _encryptAndStoreFile) ---
      // This calls the SUT's _encryptAndStoreFile method
      final encryptionResult = await secureFileStorageService.encryptAndStoreFileForTest(mockPlatformFileFromPicker);
      
      expect(encryptionResult, isNotNull, reason: "Encryption step failed");
      expect(encryptionResult!['fileId'], currentTestFileId);
      expect(encryptionResult['path'], currentTestEncryptedPath);
      expect(writtenKeyIvEncryption, isNotNull, reason: "Key/IV was not captured from secureStorage.write");
      expect(capturedEncryptedBytesForWrite, isNotNull, reason: "Encrypted bytes were not captured from writeFileAsBytes");

      // --- Mocking for Decryption Step ---
      when(mockDbHelper.getMedicalFileMetadataById(currentTestFileId)).thenAnswer((_) async => {
        DatabaseHelper.colId: currentTestFileId,
        DatabaseHelper.colOriginalFilename: pickedFileName,
        DatabaseHelper.colFileType: 'txt',
        DatabaseHelper.colEncryptedPath: currentTestEncryptedPath,
        DatabaseHelper.colFileSize: testPlaintextData.length,
      });
      // Use the captured key:IV string for the secure storage read mock
      when(mockSecureStorage.read(key: currentTestFileId)).thenAnswer((_) async => writtenKeyIvEncryption);
      when(mockFileSystemOps.fileExists(currentTestEncryptedPath)).thenAnswer((_) async => true);
      // Use the captured encrypted bytes for the file read mock
      when(mockFileSystemOps.readFileAsBytes(currentTestEncryptedPath)).thenAnswer((_) async => capturedEncryptedBytesForWrite!); 

      // --- Execute Decryption ---
      final decryptedData = await secureFileStorageService.decryptFile(currentTestFileId);

      // ASSERT FINAL OUTCOME
      expect(decryptedData, equals(testPlaintextData), reason: "Decrypted data does not match original plaintext");

      // Verify interactions for the entire flow
      verify(mockFileSystemOps.readFileAsBytes(pickedFilePath)).called(1); 
      verify(mockFileSystemOps.writeFileAsBytes(
        currentTestEncryptedPath, 
        capturedEncryptedBytesForWrite, 
        flush: true
      )).called(1); 
      final capturedMetadataListInteg = verify(mockDbHelper.saveMedicalFileMetadata(captureAny)).captured;
      expect(capturedMetadataListInteg.length, 1);
      final Map<String, dynamic> savedMetadataInteg = capturedMetadataListInteg.single as Map<String, dynamic>;
      expect(savedMetadataInteg[DatabaseHelper.colId], currentTestFileId);
      expect(savedMetadataInteg[DatabaseHelper.colOriginalFilename], pickedFileName);
      expect(savedMetadataInteg[DatabaseHelper.colFileType], 'txt');
      expect(savedMetadataInteg[DatabaseHelper.colEncryptedPath], currentTestEncryptedPath);
      expect(savedMetadataInteg[DatabaseHelper.colFileSize], testPlaintextData.length);
      expect(savedMetadataInteg[DatabaseHelper.colDateAdded], isA<int>());
      verify(mockSecureStorage.write(key: currentTestFileId, value: writtenKeyIvEncryption ?? anyNamed('value'))).called(1); 
      verify(mockSecureStorage.read(key: currentTestFileId)).called(1); 
      verify(mockFileSystemOps.fileExists(currentTestEncryptedPath)).called(1); 
      verify(mockFileSystemOps.readFileAsBytes(currentTestEncryptedPath)).called(1); 
    });

    test('pickAndSecureFile returns null if pickFileForTest returns null (using subclass)', () async {
      // Instantiate the testable service
      final testService = TestableSecureFileStorageService(
        secureStorage: mockSecureStorage,
        dbHelper: mockDbHelper,
        uuid: mockUuid,
        logger: mockLogger,
        fileSystemOps: mockFileSystemOps,
      );

      // Configure the mock behavior for pickFileForTest
      testService.mockPickFileResult = null;
      
      // Call the method under test
      final result = await testService.pickAndSecureFile();

      // Assertions
      expect(result, isNull, reason: "Result should be null when file picking returns null.");
      expect(testService.pickFileForTestCallCount, 1, reason: "pickFileForTest should be called once.");
      
      // Verify that encryptAndStoreFileForTest was not called
      expect(testService.encryptAndStoreFileForTestCallCount, 0, reason: "encryptAndStoreFileForTest should not be called if picking fails.");
      
      // Verify logger interaction
      verify(mockLogger.i(argThat(contains('File picking cancelled or failed.')))).called(1);

      // Verify no crucial side-effects of encryption/storage occurred
      verifyNever(mockSecureStorage.write(key: anyNamed('key'), value: anyNamed('value')));
      verifyNever(mockDbHelper.saveMedicalFileMetadata(any));
      verifyNever(mockFileSystemOps.writeFileAsBytes(any, any, flush: anyNamed('flush')));
    });
  });
} 